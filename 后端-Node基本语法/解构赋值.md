# 解构赋值

## 1.数组的结构赋值

### 1.1理解解构赋值

非常有用,特别在数据交互,ajax的时候,非常完美.

在ES 5中,我们想定义多个变量,同时各这些变量赋值我们可以多次声明,也可以一次声明

```js
// 多次声明
var a = 12;
var b = 5;
var c = 6;

// 一次声明过个变量
var a = 12,
	b = 5,
	c = 6;
```

在ES 6中,我们也可以采用一次声明多个变量

```js
let a = 12,
	b = 5,
	c = 6;
console.log(a,b,b);
```

但是你会发现很散,不够整齐划一,有的时候 我们需要把值存在数组中

```js
let a = 12,
	b = 5,
	c = 6;
console.log(a,b,b);
```

```js
let arr = [12,5,6];
console.log(arr[0],arr[1],arr[2])
// 你会发现不好用,还不如console a,b,c呢
// 我就想console.log(a,b,c);怎么办

let [a,b,c] = [12,5,6];  //右边是你的数据,左边是你的结构
console.log(a,b,c);    // 12,5,6
```

这就是解构赋值.

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

> #### 注意:
>
> 1. 左右两边,结构格式要保持一致

比如:

```js
let [a,b,c] = [12,[5,6]];  //右边是你的数据,左边是你的解构
console.log(a,b,c);   
// 此时结构不对,a就是12 b是一个数组[5,6], c没有解构到值就是undefined

//如果希望数据对应,则需要结构一样
let [a,[b,c]] = [12,[5,6]];
console.log(a,b,c);   //12 5 6

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

```

### 1.2不成功的解构赋值

如果解构不成功，变量的值就等于`undefined`。

```js
let [foo] = [];
let [bar, foo] = [1];
//foo 都是undefined
```

需要被赋值的数量少于接收值的变量

### 1.3不完全解构

另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

```js
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4

//上面两个例子，都属于不完全解构，但是可以成功。
```

简单理解,就是要被赋值的值数量多于接收值变量的数量

### 1.4如果模式不匹配,那么会报错

```js
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

### 1.5 默认值

我们刚说过,我们如果定义的变量比较多,而又没有给这个变量赋值,那么这个变量就是undefined,但是有的时候我们不希望他是undefined,我们希望他是一个值

解构赋值允许指定默认值。

正常靠谱的后台都会给值,但是就怕不靠谱的后台,怎么办,所有我想要定义一个默认值,后台有用后台的值,没有,用默认值,

```js
let [a,b,c = "暂无数据"] = ["aa","bb"];  
console.log(a,b,c);    //aa bb 暂无数据
// 发现此时c就是默认值"暂无数据"

// 如果有值,就使用后台的值
let [a,b,c = "暂无数据"] = ["aa","bb","cc"];  
console.log(a,b,c);    // aa bb cc

// 如果后台穿过来的是undefined,还是表示没有值,用默认值,
let [a,b,c = "暂无数据"] = ["aa","bb",undefined];  
console.log(a,b,c);    //aa bb 暂无数据

// 如果后台传过来的是一个null,表示有值,null表示一个空对象
let [a,b,c = "暂无数据"] = ["aa","bb",null];  
console.log(a,b,c);    //aa bb null
```

注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。



#### 1.5.1 如果默认值是一个表达式

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

```js
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
//等价于
let x;
if ([1][0] === undefined) {
  x = f();
} else {
  x = [1][0];
}
```



####  1.5.2默认值可以引用解构赋值的其他变量,

前提是该变量必须是已经声明的

```js
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError
//上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明
```

### 6.利用解构赋值交换两个值

交换两个值的位置

```js
let a = 12;
let b = 5;
[a,b] = [b,c];
console.log(a,b);  //5 12
// 这里利用数组有序的特性和解构赋值的方式,交互两个数
```

## 2.对象的结构赋值

### 2.1 对象解构赋值

解构不仅可以用于数组，还可以用于对象。

```js
let json = {
    name: "wuwei",
    age: 18,
    sex: "男"
}
let {name,age,sex} = json;
console.log(name,age,sex);  // wuwei 18 男
```

### 2.2对象解构赋值属性名必须相同

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```js
// 这里解构的属性名必须和对象的属性名相同,否则解不出来就全是undefined
let {nam,ag,se} = json;
console.log(nam,ag,se);  // undefined undefined undefined
```

### 2.3自定义变量名与属性名不同

```js
// 如果想自己定义更改属性名可以如下操作
let {name:nam,age:ag,sex:se} = json; // 这样依然可以改属性名,并打印了解构的值
console.log(nam,ag,se);  //wuwei 18 男
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

实际上说明，对象的解构赋值是下面形式的简写

```js
let {name:name,age:age,sex:sex} = json; // 这样依然可以改属性名,并打印了解构的值
console.log(nam,ag,se);  //wuwei 18 男
```

